{
    "netflow" : {
        "description" : "Analyze netflow nodes i.e. network sockets for possible anomalous behavior",
        "instance_set" : "IDS=g.V().has(ETYPE,CONNECT).out(E_E_A_N_O).out(E_E_A_N_I).dedup().id().toList().toArray()",
        "feature_set" : {
            "write_bytes":
                "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).values(SIZE).sum())",
            "read_bytes":
                "g.V(IDS).local(__.out(E_N_A_E_O).out(E_N_A_E_I).has(ETYPE,READ).values(SIZE).sum())",
            "num_writes":
                "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).count())",
            "num_reads":
                "g.V(IDS).local(__.out(E_N_A_E_O).out(E_N_A_E_I).has(ETYPE,READ).count())",
            "num_open":
                "g.V(IDS).local(__.out(E_N_A_E_O).out(E_N_A_E_I).has(ETYPE,OPEN).count())",
            "num_close":
                "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,CLOSE).count())",
            "duration":{
                "first":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(STYPE,EVENT).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,CONNECT).values(STIME).min())",
                "operator":
                    "subTime"
            }
        }
    },

    "netflow_connect_process_exec" : {
        "description" : "Analyze netflow nodes that have connection with file execution (potential remote execution command)",
        "instance_set" : "IDS=g.V().has(ETYPE,CONNECT).out(E_E_A_N_O).out(E_E_A_N_I).dedup().as('netflow').in(E_E_A_N_I).in(E_E_A_N_O).out(E_E_G_B_S_O).out(E_E_G_B_S_I).dedup().in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,EXECUTE).select('netflow').dedup().id().toList().toArray()",
        "feature_set" : {
            "write_bytes":
                "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).values(SIZE).sum())",
            "read_bytes":
                "g.V(IDS).local(__.out(E_N_A_E_O).out(E_N_A_E_I).has(ETYPE,READ).values(SIZE).sum())",
            "num_writes":
                "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).count())",
            "num_reads":
                "g.V(IDS).local(__.out(E_N_A_E_O).out(E_N_A_E_I).has(ETYPE,READ).count())",
            "num_open":
                "g.V(IDS).local(__.out(E_N_A_E_O).out(E_N_A_E_I).has(ETYPE,OPEN).count())",
            "num_close":
                "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,CLOSE).count())",
            "duration":{
                "first":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(STYPE,EVENT).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,CONNECT).values(STIME).min())",
                "operator":
                    "subTime"
            }
        }
    },

    "netflow_connect_last_activity_gap" : {
        "description" : "Identify netflow nodes that are open for long time",
        "instance_set": "IDS=g.V().has(ETYPE,CONNECT).out(E_E_A_N_O).out(E_E_A_N_I).dedup().id().toList().toArray()",
        "feature_set": {
            "connect_last_activity_gap":{
                "first":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(STYPE,EVENT).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,CONNECT).values(STIME).min())",
                "operator":
                    "subTime"
            }
        }
    },

    "netflow_long_write_delay" : {
        "description" : "Identify netflow nodes with long writing delay (potential exfiltration)",
        "instance_set": "IDS=g.V().has(ETYPE,CONNECT).out(E_E_A_N_O).out(E_E_A_N_I).dedup().as('netflow').local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).count().is(gt(1))).select('netflow').dedup().id().toList().toArray()",
        "feature_set": {
            "first_last_write_gap":{
                "first":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).values(STIME).min())",
                "operator":
                    "subTime"
            },
            "num_writes":
                "g.V(IDS).local(__.in(E_E_A_N_I).in(E_E_A_N_O).has(ETYPE,WRITE).count())"
        }
    },



    "process_connected_with_netflow" : {
        "description" : "Analyze process nodes that have network activity",
        "instance_set" : "IDS=g.V().has(STYPE,PROCESS).as('process').in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_N_O).out(E_E_A_N_I).select('process').dedup().id().toList().toArray()",
        "feature_set" : {
            "num_file_open_during_wr_to_netflow":
                "g.V(IDS).local(__.as('process').in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).as('writeNetflow').out(E_E_A_N_O).out(E_E_A_N_I).select('process').in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,OPEN).as('openFile').in(E_F_A_E_I).in(E_F_A_E_O).select('writeNetflow','openFile').by(STIME).where('writeNetflow',gte('openFile')).count())",
            "num_distinct_dst_port_access":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_N_O).out(E_E_A_N_I).values(DPORT).dedup().count())",
            "num_distinct_src_port_access":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_N_O).out(E_E_A_N_I).values(SPORT).dedup().count())",
            "total_bytes_sent_to_netflow":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).as('event').out(E_E_A_N_O).out(E_E_A_N_I).select('event').has(SIZE).values(SIZE).sum())",
            "total_bytes_rcv_from_netflow":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,READ).as('event').in(E_N_A_E_I).in(E_N_A_E_O).select('event').has(SIZE).values(SIZE).sum())",
            "num_writes_to_net_flow":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).out(E_E_A_N_O).out(E_E_A_N_I).count())",
            "num_reads_to_netflow":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,READ).in(E_N_A_E_I).in(E_N_A_E_O).count())"
        }
    },

    "process_connect_many_netflow" : {
        "description": "Analyze process nodes that have many distinct network activity within same network hosts",
        "instance_set": "IDS=g.V().has(STYPE,PROCESS).as('process').in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_N_O).out(E_E_A_N_I).select('process').dedup().id().toList().toArray()",
        "feature_set": {
            "max_num_local_net_access":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_N_O).out(E_E_A_N_I).dedup().groupCount().by{x=it.value(DADDRESS);x.substring(0,x.indexOf('.',x.indexOf('.',0)+1))}.mapValues().max())"
        }
    },

    "process_connect_rare_ip" : {
        "description": "Analyze process nodes that have rare ip access",
        "instance_set": "IDS=g.V().has(STYPE,PROCESS).as('process').in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_N_O).out(E_E_A_N_I).select('process').dedup().id().toList().toArray()",
        "feature_set": {
            "num_distinct_dst_ip_access":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_N_O).out(E_E_A_N_I).values(DADDRESS).dedup().count())"
        }
    },

    "process_long_write_to_netflow" : {
        "description" : "Identify process nodes with long writing delay (potential exfiltration)",
        "instance_set": "IDS=g.V().has(STYPE,PROCESS).as('process').local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).as('netflow_write').out(E_E_A_N_O).out(E_E_A_N_I).select('netflow_write').count().is(gt(1))).select('process').dedup().id().toList().toArray()",
        "feature_set": {
            "first_last_write_gap":{
                "first":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).values(STIME).min())",
                "operator":
                    "subTime"
            },
            "num_writes":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).count())"
        }
    },

    "process_write_rate_to_netflow" : {
        "description" : "Identify process with slow write rate (potential exfiltration)",
        "instance_set": "IDS=g.V().has(STYPE,PROCESS).as('process').local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).as('netflow_write').out(E_E_A_N_O).out(E_E_A_N_I).select('netflow_write').count().is(gt(1))).select('process').dedup().id().toList().toArray()",
        "feature_set": {
            "write_rate":{
                "first":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).as('netflow_write').out(E_E_A_N_O).out(E_E_A_N_I).select('netflow_write').values(SIZE).sum())",
                "second":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).values(STIME).max())",
                "third":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).values(STIME).min())",
                "operator":
                    "div(SubTime)"
            },
            "time_gap_per_writes":{
                "first":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).values(STIME).min())",
                "third":
                    "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).count())",
                "operator":
                    "(SubTime)div"
            }
        }
    },

    "process_access_file_attributes" : {
        "description" : "Analyze process that access attributes of files",
        "instance_set": "IDS=g.V().has(STYPE,PROCESS).and(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,CHECK_FILE_ATTRIBUTES),__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES)).id().toList().toArray()",
        "feature_set": {
            "num_chk_attrib":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,CHECK_FILE_ATTRIBUTES).count())",
            "num_modify_attrib":
                "g.V(IDS).local(__.in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES).count())"
        }
    },



    "files_connected_with_netflow" : {
        "description" : "Analyze files that have connection with netflow (potential downloaded files)",
        "instance_set" : "IDS=g.V().has(STYPE,EVENT).as('net_events').out(E_E_A_N_O).select('net_events').out(E_E_G_B_S_O).out(E_E_G_B_S_I).dedup().in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_F_O).out(E_E_A_F_I).dedup().id().toList().toArray()",
        "feature_set" : {
            "num_exec":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,EXECUTE).count())",
            "num_close":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,CLOSE).count())",
            "num_chk_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,CHECK_FILE_ATTRIBUTES).count())",
            "num_modify_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES).count())",
            "num_open":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,OPEN).count())",
            "num_read":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,READ).count())",
            "num_rename":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,RENAME).count())",
            "num_write":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).count())",
            "num_uploads":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,READ).as('file_read').out(E_E_G_B_S_O).out(E_E_G_B_S_I).as('process').in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).as('netflow_write').out(E_E_A_N_O).out(E_E_A_N_I).dedup().count())"
        }
    },

    "files_executed" : {
        "description" : "Analyze executed files",
        "instance_set" : "IDS=g.V().has(ETYPE,EXECUTE).in(E_F_A_E_I).in(E_F_A_E_O).dedup().id().toList().toArray()",
        "feature_set" : {
            "num_exec":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,EXECUTE).count())",
            "num_close":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,CLOSE).count())",
            "num_chk_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,CHECK_FILE_ATTRIBUTES).count())",
            "num_modify_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES).count())",
            "num_open":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,OPEN).count())",
            "num_read":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,READ).count())",
            "num_rename":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,RENAME).count())",
            "num_write":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).count())"
        }
    },

    "file_open_close_gap" : {
        "description" : "Identify files that are open for long time",
        "instance_set": "IDS=g.V().has(ETYPE,CLOSE).in(E_F_A_E_I).in(E_F_A_E_O).dedup().as('files').out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,OPEN).select('files').dedup().id().toList().toArray()",
        "feature_set": {
            "open_close_gap":{
                "first":
                    "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,CLOSE).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,OPEN).values(STIME).min())",
                "operator":
                    "subTime"
            }
        }
    },

    "files_connect_netflow_long_write" : {
        "description" : "Identify files connected with netflow and with long writing delay (potential exfiltration)",
        "instance_set" : "IDS=g.V().has(ETYPE,WRITE).as('write_events').out(E_E_A_N_O).select('write_events').out(E_E_G_B_S_O).out(E_E_G_B_S_I).dedup().in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).out(E_E_A_F_O).out(E_E_A_F_I).dedup().id().toList().toArray()",
        "feature_set": {
            "first_last_write_gap":{
                "first":
                    "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).values(STIME).min())",
                "operator":
                    "subTime"
            },
            "num_writes":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).count())"
        }
    },

    "file_dnld_exec_gap" : {
        "description" : "Detect files that are executed right after download",
        "instance_set": "IDS=g.V().has(ETYPE,EXECUTE).in(E_F_A_E_I).in(E_F_A_E_O).dedup().as('files').in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).select('files').dedup().id().toList().toArray()",
        "feature_set": {
            "dnld_exec_gap":{
                "first":
                    "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,EXECUTE).values(STIME).min())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).values(STIME).max())",
                "operator":
                    "subTime"
            }
        }
    },

    "file_attrib_change_exec_gap" : {
        "description" : "Detect files that are executed right after permission change",
        "instance_set": "IDS=g.V().has(ETYPE,EXECUTE).in(E_F_A_E_I).in(E_F_A_E_O).dedup().as('files').in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES).select('files').dedup().id().toList().toArray()",
        "feature_set": {
            "attrib_change_exec_gap":{
                "first":
                    "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,EXECUTE).values(STIME).min())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES).values(STIME).max())",
                "operator":
                    "subTime"
            }
        }
    },

    "file_exec_del_gap" : {
        "description" : "Detect files that are deleted right after execution",
        "instance_set": "IDS=g.V().has(ETYPE,EXECUTE).in(E_F_A_E_I).in(E_F_A_E_O).dedup().as('files').in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,UNLINK).select('files').dedup().id().toList().toArray()",
        "feature_set": {
            "exec_del_gap":{
                "first":
                    "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,EXECUTE).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,UNLINK).values(STIME).min())",
                "operator":
                    "subTime"
            }
        }
    },

    "file_upload_del_gap" : {
        "description" : "Detect files that are deleted right after upload",
        "instance_set": "IDS=g.V().has(ETYPE,UNLINK).out(E_E_A_F_O).out(E_E_A_F_I).dedup().as('files').out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,READ).out(E_E_G_B_S_O).out(E_E_G_B_S_I).dedup().in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).out(E_E_A_N_O).out(E_E_A_N_I).select('files').dedup().id().toList().toArray()",
        "feature_set": {
            "upload_del_gap":{
                "first":
                    "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,READ).out(E_E_G_B_S_O).out(E_E_G_B_S_I).dedup().in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,WRITE).as('netflow_write').out(E_E_A_N_O).out(E_E_A_N_I).select('netflow_write').values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,UNLINK).values(STIME).min())",
                "operator":
                    "subTime"
            }
        }
    },

    "file_last_write_upload_gap" : {
        "description" : "Detect files that are uploaded right after write (potential exfiltration)",
        "instance_set": "IDS=g.V().has(ETYPE,WRITE).as('write_events').out(E_E_A_N_O).select('write_events').out(E_E_G_B_S_O).out(E_E_G_B_S_I).dedup().in(E_E_G_B_S_I).in(E_E_G_B_S_O).has(ETYPE,READ).in(E_F_A_E_I).in(E_F_A_E_O).dedup().id().toList().toArray()",
        "feature_set": {
            "exec_del_gap":{
                "first":
                    "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,READ).values(STIME).max())",
                "second":
                    "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,WRITE).values(STIME).min())",
                "operator":
                    "subTime"
            }
        }
    },

    "files_executed_attribute_access" : {
        "description" : "Analyze file attribute access/change for executed files",
        "instance_set": "IDS=g.V().has(ETYPE,EXECUTE).in(E_F_A_E_I).in(E_F_A_E_O).dedup().id().toList().toArray()",
        "feature_set": {
            "num_chk_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,CHECK_FILE_ATTRIBUTES).count())",
            "num_modify_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES).count())"
        }
    },

    "files_in_tmp_dir_connect_netflow" : {
        "description" : "Analyze the files in temp directory and have connection with netflow",
        "instance_set": "IDS=g.V().has(STYPE,EVENT).as('net_events').out(E_E_A_N_O).select('net_events').out(E_E_G_B_S_O).out(E_E_G_B_S_I).dedup().in(E_E_G_B_S_I).in(E_E_G_B_S_O).out(E_E_A_F_O).out(E_E_A_F_I).dedup().has('url',textContains('/tmp')).id().toList().toArray()",
        "feature_set": {
            "num_exec":
                "g.V(IDS).local(__.out(E_F_A_E_O).out(E_F_A_E_I).has(ETYPE,EXECUTE).count())",
            "num_chk_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,CHECK_FILE_ATTRIBUTES).count())",
            "num_modify_attrib":
                "g.V(IDS).local(__.in(E_E_A_F_I).in(E_E_A_F_O).has(ETYPE,MODIFY_FILE_ATTRIBUTES).count())"
        }
    }
}
