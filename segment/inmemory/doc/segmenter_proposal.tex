

\documentclass{article}

\usepackage{hyperref}

\usepackage{fullpage}
\usepackage{a4}

\begin{document}
\title{A proposal for a baseline segmenter}
\maketitle

We plan to implement an extremely simple segmenter with the aim
of having a starting point for experimentation. This will hopefully
help us interact with the other project groups to identify requirements
for the segmenter and, in general, 
concretize our research plan.

Our segmenter extracts several subgraphs from a given 
RDF graph according to a time span.
An RDF graph is simply a labeled directed graph, 
i.e. a set of edges of the form $s \to^p o$,
and hence RDF graphs are typically represented 
as a set of triples of the form $(s,p,o)$.
\\[2ex]
More concretely, our segmenter takes as input
\begin{enumerate}
\item an RDF graph $G$ in Turtle format and
\item an interval duration $T$ (in microseconds),
\end{enumerate}
and produces the sequence of RDF graphs that corresponds to {\em the time-based segmentation of $G$ according to $T$}.

Let us now describe what we mean by {\em the time-based segmentation of $G$ according to $T$}.
As mentioned above, $G$ is a set of ordered triples $(s, p, o)$,
where $s$, $p$, and $o$ intuitively stand for subject, predicate, and object, respectively.
For example, the following are triples in turtle format
generated by the PARC team using the approach described in 
Manolis Stamatogiannakis et al.'s paper ``Decoupling Provenance Capture and
Analysis from Execution''~\cite{stamatogiannakis15tapp}.

{\scriptsize
\begin{verbatim}
<exe://bash~2819~2723> prov:startedAtTime 1519337 .
<exe://bash~2819~2723> prov:endedAtTime 1820209 . 
<file:/usr/lib/locale/locale-archive> adapt:wasAccessedBy <exe://mkdir~2820~2819> . 
<file:/tmp/prov\_files/alpaca.txt> prov:wasGeneratedBy <exe://bash~2824~2819> .
\end{verbatim}
}

Our segmenter exploits the information provided 
by the predicates startedAtTime and endedAtTime
to produce a list of subgraphs of $G$.
The RDF graph generated by the PARC team referred above
contains the relations: 
type, startedAtTime,
wasAccessedBy,
endedAtTime,
wasGeneratedBy,
wasDerivedFrom,
label, and
used.
Note that the only triples that refer to time 
are the ones with predicates
startedAtTime and endedAtTime.
Also, let us remark that not every 
subject in the graph has a 
startedAtTime and endedAtTime
predicate.
\\[2ex]
Our segmenter proceeds as follows:

1) The minimum $A$ and maximum $B$ absolute times mentioned in $G$ are computed.

2) Let $L = (a_1, b_1), \ldots, (a_n, b_n)$ be the list of all consecutive non-overlapping
time intervals of duration $T$ between $A$ and $B$. For each $(a_i, b_i)$ the segmenter outputs an RDF graph $G_i$ constructed as follows:

(a) If there is a triple $(s, startedAtTime, o)\in G$ such that $o>b_i$, the subject $s$ is marked as {\em unstarted}.

(b) If there is a triple $(s, endedAtTime, o)\in G$ such that $o>a_i$, $s$ is marked as {\em unfinished}.

(c) Subjects, objects, and triples are marked according to the following rules:
\begin{itemize}
\item[R1.] If there is a triple $(s, wasGeneratedBy, o)\in G$ 
such that $o$ is unstarted then $s$ is marked as unstarted.
\item[R2.] If there is a triple $(s, wasDerivedFrom, o)\in G$ 
such that $o$ is unstarted then $s$ is marked as unstarted.
\item[R3.] A triple $(s, used, o)$ such that $o$ is unstarted is marked as unstarted.
\item[R4.] A triple $(s, wasAccessedBy, o)$ such that $o$ is unstarted is marked as unstarted.
\end{itemize}
(d) $G_i$ is obtained from $G$ by, after having applied the rules R1-R4 exhaustively, 
removing unstarted triples and triples with unstarted subject or object.

Similar rules can be added for subjects marked as {\em finished}, one could also think of 
other markings, such as {\em ongoing} or {\em expired}, with their corresponding rules.

\section{Segmentation specifications}

We use \emph{segmentation specifications} to describe what kinds of
segments to construct and how to annotate the resulting segment layer
nodes.

The abstract syntax of segmentation specifications is as follows:
\begin{verbatim}
<rule>  ::= segment <name> (<prop> = <exp>, ...) by <specs>
<specs> ::= <spec> | <spec> and <specs>
<spec>  ::= time window <time> (from <time> )? (starting <var>)?
         | radius <num> from <prop>=<exp> (following <edges>)
         
<prop> = property names
<var> = variables
<exp> = <num> | <string> | <var>
<num> = numbers
<string> = string literals
<time> = times/durations
<edges> = sets of edge names
\end{verbatim}

For convenience, we represent such specifications as JSON data
structures to save effort on parsing and so on.  An example is shown
in Figure~\ref{fig:seg-spec}.

\begin{figure}[tb]\centering
(a)
\begin{verbatim}
segment byPidTime(pid=X, startTime=T) 
     by radius 3 from PID=X  
         following {"wasDerivedFrom", "used", "wasGeneratedBy",
                    "wasAssociatedWith", "wasInvalidatedBy"}
    and time window 24:00:00 from 2013-03-16T00:00:00 starting T
\end{verbatim}

(b)
\begin{verbatim}
{"segmentation_specification" : 
 {"segment" :
  {"name": "byPidTime",
   "args": [{"property" : "pid", "value" : {"var" : "X"}},
            {"property" : "startTime", "value" : {"var" : "T"}}],
   "specifications" : [
       {"radius" : { "r" : 3,
                     "from" : {"property" : "PID", "var": "X"},
                     "edges" : ["wasDerivedFrom", 
                                "used", 
                                "wasGeneratedBy", 
                                "wasAssociatedWith", 
                                "wasInvalidatedBy"]}},
       {"time" : {"window" : {"days" : 0, 
                              "hours" : 24, 
                              "minutes" : 0, 
                              "seconds" : 0},
                  "from" : "2013-03-16T00:00:00",
                  "starting" : {"var" : "T"}}}
   ]
  }
 }
}
\end{verbatim}
  
  \caption{An example segmentation specification and its JSON representation}
  \label{fig:seg-spec}
\end{figure}

The idea here is that each ``spec'' is a rule for identifying matching
subgraphs, and this matching process may also result in binding some
variables to values.  The segment name is a special property that
every segment has, so that we can tell different kinds of segments
apart, and the additional \verb|<prop>=<exp>| pairs are additional
properties that get added to the resulting segment node, so that we
can see that e.g. a given segment is for PID 42's activity starting at
a given time.  We can choose to include more information (such as the
duration) or less.

For time windows, the window time is the duration of each segment, and
the ``from'' time is the time of the first segment in the window series.
``starting X'' means that for each resulting segment, X is bound to the
start time of the segment's time window.  (The end time could also be
stored, but is recoverable from the segment specification and the
start time.)

For radius segments I just have in mind specifying all of the edges
that may be followed (and they can be followed in any order).  This
may be fragile so we may want to introduce a way to define named sets
of edges and reuse them.  For now, we can use wasInfluencedBy as a way
to specify all of the standard edges.

Each specification produces (conceptually) a set of subgraphs and a
binding of the variables in the specification.  This results in a new
segment node linked to (the nodes of the) subgraph, with a segment
name property set to the declared name, and any additional properties
set using the values of the variables.  ``and'' (conceptually) combines
the results of two specifications as follows: for each pair $(SG1,env1)$
in the result of $spec1$ and $(SG2,env2)$ in the result of $spec2$, if $SG1$
overlaps with $SG2$ and $env1$ and $env2$ are compatible environments,
produce $(SG1 \cap SG2, env1 + env2)$ where $env1 + env2$ is the merge of
the two environments.  (It probably makes sense to restrict attention
to rules that do not reuse variables, so that combining environments
is always possible).

\subsection{Formal semantics}

Fix sets $\Gamma$ of property names, $\Sigma$ of edge labels, and $D$
of data values.  We assume that there is a special attribute $time$
associating certain nodes with times.

Let $G = (V,E, \alpha, \lambda)$ be a graph where
$\alpha : V\times \Gamma \to D_\bot$ associates each property name
with an optional data value, and $\lambda : E \to \Sigma$ associates a
label to each edge.

A graph $G' = (V',E',\alpha',\lambda')$ is a subgraph of $G$ if (as
usual) $V' subseteq V$, $E'\subseteq E$ and the labels in $G'$ are
compatible with those in $G$, that is, for all $v\in V'$ and all $p
\in \Gamma$ we have $\alpha'(v,p) = \alpha(v,p)$, and
similarly for all $e \in E'$ we have $\lambda'(e) = \lambda(e)$.
Since $\alpha'$ and $\lambda'$ are obtainable by restriction, we can
represent a subgraph just as a set of nodes and edges.  


A valuation is a partial mapping $\rho : Var \to D_\bot$ from
variables to data values.

We now fix an ambient graph $G$ by which all subsequent definitions
are parameterized.

The result of segmentation of a graph $G$ is a set of pairs
$(SG,\rho)$ where $SG$ is a subgraph of $G$ and $\rho$ is a
valuation.  


In what follows, we discuss how to segment a graph $G' = (V',E')$ which may be
$G$ itself (initially) or a subgraph of $G$.  

\verb|radius N from p = X following S|: Suppose $N$ is the radius, $p$
is the property name and $S$ is the set of possible edge labels to
follow.  Suppose $v \in V'$.  Then we define $Radius(G',v,N,S)$ to be the
subgraph of $G'$ obtained by adding $v$ and all nodes reachable from
$v$ by paths of length $\leq N$ following edges whose labels are in
$S$.  Then the result of segmentation is 

\[\{ (Radius(G',v,N,S),[X=d] \mid \alpha(v,p) = d\}\]

that is we generate one segment for each node in $G'$ having $p = d$
for some $d$, and we record this choice in the valuation.


\verb|time window T_s from T_s starting X|: Suppose $t_s$ is the start
time, and $t_w$ is the window length.  Consider the periodic intervals
starting at $t_w$ with period $t_d$ as follows:
\[[t_s, t_s+t_d), [t_s + t_d, t_s + 2t_d), \ldots, [t_s+nt_d, t_s +
(n+1)t_d),\ldots\]
 In a finite graph
$G'$ there is a finite subset of these intervals that contains all
$time$ property values present in $G'$.  Let $Starts(G')$ be the set of
starting times of such intervals, that is, 
\[Starts = \{t_s + nt_d \mid \exists v \in V'. t_s+nt_d \leq
\alpha(v,time) < t_s + (n+1)t_d\}\]

 We define $Time(G',I)$ as the subgraph of $G'$ obtained by
retaining all nodes with a time property in interval $I$, and all
edges between such nodes.
\[\{(Time(G',[t,t+t_d)), [X=t]) \mid t \in Starts(G')\}\]


\verb|spec1 and spec2|: Let $Y_1$ be the result of segmenting $G'$
according to $spec1$ and $Y_2$ the result of segmenting according to
$spec2$.  Also, we assume that the variables bound in $spec1$ and
$spec2$ are disjoint, so the resulting valuations have disjoint domains.

  The result of segmenting according to \verb|spec1 and spec2| is:

\[\{(SG_1 \cap SG_2, \rho_1 \uplus \rho_2)  \mid (SG_1,\rho_1) \in
Y_1, (SG_2,\rho_2) \in Y_2\}\]

\verb|spec1 then spec2|: Let $Y_1$ be the result of segmenting
$G'$ according to $spec1$.  For any subgraph $SG$ of $G'$, let $Y_2(SG)$ be
the result of segmenting $SG$ according to $spec2$.  Also, we assume that the variables bound in $spec1$ and
$spec2$ are disjoint, so the resulting valuations have disjoint
domains.  

We can also consider an alternative segmentation combinator
\verb|then| that ``sequentially composes'' segmentation
specifications.  The result of segmenting according to
\verb|spec1 then spec2| is:

\[\{(SG_2, \rho_1 \uplus \rho_2)  \mid (SG_1,\rho_1) \in
Y_1, (SG_2,\rho_2) \in Y_2(SG_1)\}\]

The difference between $and$ and $then$ is that $and$ considers each
specification independently on the
current graph, and takes the intersection of the resulting subgraphs, whereas $then$ segments using the first specification,
then ``focuses'' on each resulting subgraph and segments each one
using the second specification.  The variable bindings are combined
using $\uplus$ in either case.

For the time being, we include empty segments in the result.

Each segment in the final result corresponds to a new segment node,
whose name property is set to the declared segment name, and other
properties are set to the values obtained from the corresponding.  The
node is also linked to all of the nodes in the segment (at least for
now; there isn't a convenient way to link a node to an edge in Titan.)

\subsection{Edges among segments (todo)}

Currently we do not define explicit edges among segments.  However,
since the segments are linked to the nodes of their subgraphs, such
edges can be defined implicitly as queries.  For example, we could
define an edge relationship between segment nodes to hold if there is
a (directed) path from a node in one segment to a node in another.
It is not yet clear whether we want to (or need to) persist such edges
in the database or simply generate them on the fly when the segment
layer is analyzed.

\bibliographystyle{plain}
\bibliography{bib}

\end{document}

%  LocalWords:  segmenter
