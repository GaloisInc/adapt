/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package com.bbn.tc.schema.avro;

import org.apache.avro.specific.SpecificData;

@SuppressWarnings("all")
/** *  Objects, in general, represent data sources and sinks which
     *  could include sockets, files, memory, and any data in general
     *  that can be an input and/or output to an event.  This record
     *  is intended to be abstract i.e., one should not instantiate an
     *  Object but rather instantiate one of its sub types (ie,
     *  encapsulating records) FileObject, UnnamedPipeObject,
     *  RegistryKeyObject, NetFlowObject, MemoryObject, or
     *  SrcSinkObject. */
@org.apache.avro.specific.AvroGenerated
public class AbstractObject extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = -6844597933864731689L;
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"AbstractObject\",\"namespace\":\"com.bbn.tc.schema.avro\",\"doc\":\"*  Objects, in general, represent data sources and sinks which\\n     *  could include sockets, files, memory, and any data in general\\n     *  that can be an input and/or output to an event.  This record\\n     *  is intended to be abstract i.e., one should not instantiate an\\n     *  Object but rather instantiate one of its sub types (ie,\\n     *  encapsulating records) FileObject, UnnamedPipeObject,\\n     *  RegistryKeyObject, NetFlowObject, MemoryObject, or\\n     *  SrcSinkObject.\",\"fields\":[{\"name\":\"source\",\"type\":{\"type\":\"enum\",\"name\":\"InstrumentationSource\",\"doc\":\"* InstrumentationSource identifies the source reporting provenance information.\\n     *\\n     * SOURCE_ANDROID_JAVA_CLEARSCOPE,    from android java instrumentation\\n     * SOURCE_ANDROID_NATIVE_CLEARSCOPE,  from android's native instrumentation\\n     * SOURCE_FREEBSD_OPENBSM_TRACE,      from FreeBSD openBSM\\n     * SOURCE_FREEBSD_DTRACE_CADETS,      from CADETS freebsd instrumentation\\n     * SOURCE_FREEBSD_TESLA_CADETS,       from CADETS freebsd instrumentation\\n     * SOURCE_FREEBSD_LOOM_CADETS,        from CADETS freebsd instrumentation\\n     * SOURCE_FREEBSD_MACIF_CADETS,       from CADETS freebsd instrumentation\\n     * SOURCE_LINUX_AUDIT_TRACE,          from Linux /dev/audit\\n     * SOURCE_LINUX_PROC_TRACE,           from Linux's /proc\\n     * SOURCE_LINUX_BEEP_TRACE,           from BEEP instrumentation\\n     * SOURCE_LINUX_THEIA                 from the GATech THEIA instrumentation source\\n     * SOURCE_WINDOWS_DIFT_FAROS,         from FAROS' DIFT module\\n     * SOURCE_WINDOWS_PSA_FAROS,          from FAROS' PSA module\\n     * SOURCE_WINDOWS_FIVEDIRECTIONS      for the fivedirections windows events\",\"symbols\":[\"SOURCE_ANDROID_JAVA_CLEARSCOPE\",\"SOURCE_ANDROID_NATIVE_CLEARSCOPE\",\"SOURCE_FREEBSD_OPENBSM_TRACE\",\"SOURCE_FREEBSD_DTRACE_CADETS\",\"SOURCE_FREEBSD_TESLA_CADETS\",\"SOURCE_FREEBSD_LOOM_CADETS\",\"SOURCE_FREEBSD_MACIF_CADETS\",\"SOURCE_LINUX_AUDIT_TRACE\",\"SOURCE_LINUX_PROC_TRACE\",\"SOURCE_LINUX_BEEP_TRACE\",\"SOURCE_LINUX_THEIA\",\"SOURCE_WINDOWS_DIFT_FAROS\",\"SOURCE_WINDOWS_PSA_FAROS\",\"SOURCE_WINDOWS_FIVEDIRECTIONS\"]},\"doc\":\"The source that emitted the object, see InstrumentationSource\"},{\"name\":\"permission\",\"type\":[\"null\",{\"type\":\"fixed\",\"name\":\"SHORT\",\"size\":2}],\"doc\":\"Permission bits defined over the object (Optional)\",\"default\":null},{\"name\":\"epoch\",\"type\":[\"null\",\"int\"],\"doc\":\"* Used to track when an object is deleted and a new one is\\n         * created with the same identifier. This is useful for when\\n         * UUIDs are based on something not likely to be unique, such\\n         * as file path.\",\"default\":null},{\"name\":\"properties\",\"type\":[\"null\",{\"type\":\"map\",\"values\":\"string\"}],\"doc\":\"* Arbitrary key, value pairs describing the entity.\\n         * NOTE: This attribute is meant as a temporary place holder for items that\\n         * will become first-class attributes in the next CDM version.\",\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }
  /** The source that emitted the object, see InstrumentationSource */
  @Deprecated public InstrumentationSource source;
  /** Permission bits defined over the object (Optional) */
  @Deprecated public SHORT permission;
  /** * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path. */
  @Deprecated public java.lang.Integer epoch;
  /** * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version. */
  @Deprecated public java.util.Map<java.lang.CharSequence,java.lang.CharSequence> properties;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public AbstractObject() {}

  /**
   * All-args constructor.
   * @param source The source that emitted the object, see InstrumentationSource
   * @param permission Permission bits defined over the object (Optional)
   * @param epoch * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path.
   * @param properties * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version.
   */
  public AbstractObject(InstrumentationSource source, SHORT permission, java.lang.Integer epoch, java.util.Map<java.lang.CharSequence,java.lang.CharSequence> properties) {
    this.source = source;
    this.permission = permission;
    this.epoch = epoch;
    this.properties = properties;
  }

  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call.
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return source;
    case 1: return permission;
    case 2: return epoch;
    case 3: return properties;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  // Used by DatumReader.  Applications should not call.
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: source = (InstrumentationSource)value$; break;
    case 1: permission = (SHORT)value$; break;
    case 2: epoch = (java.lang.Integer)value$; break;
    case 3: properties = (java.util.Map<java.lang.CharSequence,java.lang.CharSequence>)value$; break;
    default: throw new org.apache.avro.AvroRuntimeException("Bad index");
    }
  }

  /**
   * Gets the value of the 'source' field.
   * @return The source that emitted the object, see InstrumentationSource
   */
  public InstrumentationSource getSource() {
    return source;
  }

  /**
   * Sets the value of the 'source' field.
   * The source that emitted the object, see InstrumentationSource
   * @param value the value to set.
   */
  public void setSource(InstrumentationSource value) {
    this.source = value;
  }

  /**
   * Gets the value of the 'permission' field.
   * @return Permission bits defined over the object (Optional)
   */
  public SHORT getPermission() {
    return permission;
  }

  /**
   * Sets the value of the 'permission' field.
   * Permission bits defined over the object (Optional)
   * @param value the value to set.
   */
  public void setPermission(SHORT value) {
    this.permission = value;
  }

  /**
   * Gets the value of the 'epoch' field.
   * @return * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path.
   */
  public java.lang.Integer getEpoch() {
    return epoch;
  }

  /**
   * Sets the value of the 'epoch' field.
   * * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path.
   * @param value the value to set.
   */
  public void setEpoch(java.lang.Integer value) {
    this.epoch = value;
  }

  /**
   * Gets the value of the 'properties' field.
   * @return * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version.
   */
  public java.util.Map<java.lang.CharSequence,java.lang.CharSequence> getProperties() {
    return properties;
  }

  /**
   * Sets the value of the 'properties' field.
   * * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version.
   * @param value the value to set.
   */
  public void setProperties(java.util.Map<java.lang.CharSequence,java.lang.CharSequence> value) {
    this.properties = value;
  }

  /**
   * Creates a new AbstractObject RecordBuilder.
   * @return A new AbstractObject RecordBuilder
   */
  public static AbstractObject.Builder newBuilder() {
    return new AbstractObject.Builder();
  }

  /**
   * Creates a new AbstractObject RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new AbstractObject RecordBuilder
   */
  public static AbstractObject.Builder newBuilder(AbstractObject.Builder other) {
    return new AbstractObject.Builder(other);
  }

  /**
   * Creates a new AbstractObject RecordBuilder by copying an existing AbstractObject instance.
   * @param other The existing instance to copy.
   * @return A new AbstractObject RecordBuilder
   */
  public static AbstractObject.Builder newBuilder(AbstractObject other) {
    return new AbstractObject.Builder(other);
  }

  /**
   * RecordBuilder for AbstractObject instances.
   */
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<AbstractObject>
    implements org.apache.avro.data.RecordBuilder<AbstractObject> {

    /** The source that emitted the object, see InstrumentationSource */
    private InstrumentationSource source;
    /** Permission bits defined over the object (Optional) */
    private SHORT permission;
    /** * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path. */
    private java.lang.Integer epoch;
    /** * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version. */
    private java.util.Map<java.lang.CharSequence,java.lang.CharSequence> properties;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(AbstractObject.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.source)) {
        this.source = data().deepCopy(fields()[0].schema(), other.source);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.permission)) {
        this.permission = data().deepCopy(fields()[1].schema(), other.permission);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.epoch)) {
        this.epoch = data().deepCopy(fields()[2].schema(), other.epoch);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.properties)) {
        this.properties = data().deepCopy(fields()[3].schema(), other.properties);
        fieldSetFlags()[3] = true;
      }
    }

    /**
     * Creates a Builder by copying an existing AbstractObject instance
     * @param other The existing instance to copy.
     */
    private Builder(AbstractObject other) {
            super(SCHEMA$);
      if (isValidValue(fields()[0], other.source)) {
        this.source = data().deepCopy(fields()[0].schema(), other.source);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.permission)) {
        this.permission = data().deepCopy(fields()[1].schema(), other.permission);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.epoch)) {
        this.epoch = data().deepCopy(fields()[2].schema(), other.epoch);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.properties)) {
        this.properties = data().deepCopy(fields()[3].schema(), other.properties);
        fieldSetFlags()[3] = true;
      }
    }

    /**
      * Gets the value of the 'source' field.
      * The source that emitted the object, see InstrumentationSource
      * @return The value.
      */
    public InstrumentationSource getSource() {
      return source;
    }

    /**
      * Sets the value of the 'source' field.
      * The source that emitted the object, see InstrumentationSource
      * @param value The value of 'source'.
      * @return This builder.
      */
    public AbstractObject.Builder setSource(InstrumentationSource value) {
      validate(fields()[0], value);
      this.source = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'source' field has been set.
      * The source that emitted the object, see InstrumentationSource
      * @return True if the 'source' field has been set, false otherwise.
      */
    public boolean hasSource() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'source' field.
      * The source that emitted the object, see InstrumentationSource
      * @return This builder.
      */
    public AbstractObject.Builder clearSource() {
      source = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'permission' field.
      * Permission bits defined over the object (Optional)
      * @return The value.
      */
    public SHORT getPermission() {
      return permission;
    }

    /**
      * Sets the value of the 'permission' field.
      * Permission bits defined over the object (Optional)
      * @param value The value of 'permission'.
      * @return This builder.
      */
    public AbstractObject.Builder setPermission(SHORT value) {
      validate(fields()[1], value);
      this.permission = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'permission' field has been set.
      * Permission bits defined over the object (Optional)
      * @return True if the 'permission' field has been set, false otherwise.
      */
    public boolean hasPermission() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'permission' field.
      * Permission bits defined over the object (Optional)
      * @return This builder.
      */
    public AbstractObject.Builder clearPermission() {
      permission = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'epoch' field.
      * * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path.
      * @return The value.
      */
    public java.lang.Integer getEpoch() {
      return epoch;
    }

    /**
      * Sets the value of the 'epoch' field.
      * * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path.
      * @param value The value of 'epoch'.
      * @return This builder.
      */
    public AbstractObject.Builder setEpoch(java.lang.Integer value) {
      validate(fields()[2], value);
      this.epoch = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'epoch' field has been set.
      * * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path.
      * @return True if the 'epoch' field has been set, false otherwise.
      */
    public boolean hasEpoch() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'epoch' field.
      * * Used to track when an object is deleted and a new one is
         * created with the same identifier. This is useful for when
         * UUIDs are based on something not likely to be unique, such
         * as file path.
      * @return This builder.
      */
    public AbstractObject.Builder clearEpoch() {
      epoch = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'properties' field.
      * * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version.
      * @return The value.
      */
    public java.util.Map<java.lang.CharSequence,java.lang.CharSequence> getProperties() {
      return properties;
    }

    /**
      * Sets the value of the 'properties' field.
      * * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version.
      * @param value The value of 'properties'.
      * @return This builder.
      */
    public AbstractObject.Builder setProperties(java.util.Map<java.lang.CharSequence,java.lang.CharSequence> value) {
      validate(fields()[3], value);
      this.properties = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'properties' field has been set.
      * * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version.
      * @return True if the 'properties' field has been set, false otherwise.
      */
    public boolean hasProperties() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'properties' field.
      * * Arbitrary key, value pairs describing the entity.
         * NOTE: This attribute is meant as a temporary place holder for items that
         * will become first-class attributes in the next CDM version.
      * @return This builder.
      */
    public AbstractObject.Builder clearProperties() {
      properties = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    @Override
    public AbstractObject build() {
      try {
        AbstractObject record = new AbstractObject();
        record.source = fieldSetFlags()[0] ? this.source : (InstrumentationSource) defaultValue(fields()[0]);
        record.permission = fieldSetFlags()[1] ? this.permission : (SHORT) defaultValue(fields()[1]);
        record.epoch = fieldSetFlags()[2] ? this.epoch : (java.lang.Integer) defaultValue(fields()[2]);
        record.properties = fieldSetFlags()[3] ? this.properties : (java.util.Map<java.lang.CharSequence,java.lang.CharSequence>) defaultValue(fields()[3]);
        return record;
      } catch (Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  private static final org.apache.avro.io.DatumWriter
    WRITER$ = new org.apache.avro.specific.SpecificDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  private static final org.apache.avro.io.DatumReader
    READER$ = new org.apache.avro.specific.SpecificDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

}
