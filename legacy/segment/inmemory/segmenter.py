#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    =======
    `RDF-Segmenter` --- Main module
    =======

    This module implements an extremely simple time-based RDF segmenter.
    The main program takes as inputs
        (i) an RDF graph G in turtle format and
        (ii) an interval duration T (in microseconds),
    and produces the sequence of RDF graphs that correspond to the segmentation of G
    according to T.

    Adria Gascon, 2015.
"""

import os
import argparse
import sys
import rdflib
import networkx as NX
import rdflib.tools

ENDED_AT_TIME = 'http://www.w3.org/ns/prov#endedAtTime'
STARTED_AT_TIME = 'http://www.w3.org/ns/prov#startedAtTime'
WAS_GENERATED_BY = 'http://www.w3.org/ns/prov#wasGeneratedBy'
WAS_DERIVED_FROM = 'http://www.w3.org/ns/prov#wasDerivedFrom'
WAS_ACCESSED_BY = 'http://www.w3.org/ns/prov#wasAccessedBy'
USED = 'http://www.w3.org/ns/prov#used'
TIME = 'http://spade.csl.sri.com/rdf/audit-tc.rdfs#time'


VERBOSE = True


class Segmenter:
    """
    This class implements a time-based segmenter.
    The segmenter relies on the PROV events:

        ENDED_AT_TIME = 'http://www.w3.org/ns/prov#endedAtTime'
        STARTED_AT_TIME = 'http://www.w3.org/ns/prov#startedAtTime'
        WAS_GENERATED_BY = 'http://www.w3.org/ns/prov#wasGeneratedBy'
        WAS_DERIVED_FROM = 'http://www.w3.org/ns/prov#wasDerivedFrom'
        WAS_ACCESSED_BY = 'http://www.w3.org/ns/prov#wasAccessedBy'
        USED = 'http://www.w3.org/ns/prov#used'


    and the tc events:
        TIME = http://spade.csl.sri.com/rdf/audit-tc.rdfs#time

    """

    def __init__(self, filepath, interval_len):
        self.filepath = filepath
        self.rdf_graph = rdflib.Graph()
        self.rdf_graph.parse(source=filepath, format='n3')
        self.graph = NX.MultiDiGraph()
        for (s, p, o) in self.rdf_graph:
            self.graph.add_edge(s, o, label=p)
        self.interval_len = interval_len

        self.smallest_time = None
        self.biggest_time = None

        for s, p, o in self.rdf_graph:
            p_str = str(p)
            if str(p) == STARTED_AT_TIME or str(p) == TIME:
                self.smallest_time = int(o) if not self.smallest_time or self.smallest_time > int(o) \
                    else self.smallest_time
            if str(p) == ENDED_AT_TIME or str(p) == TIME:
                self.biggest_time = int(o) if not self.biggest_time or self.biggest_time < int(o) \
                    else self.biggest_time

    def segment(self):
        time_frames = range(self.smallest_time, self.biggest_time + 1, self.interval_len)
        disjoint_intervals = [tuple(time_frames[i:i + 2]) for i in range(0, len(time_frames) - 1)]
        for (t_start, t_end) in disjoint_intervals:
            unstarted_res, unstarted_rel = seg.mark_graph(t_start, t_end)
            triples_to_be_removed = []
            for (s, p, o) in seg.rdf_graph:
                if s in unstarted_res or o in unstarted_res:
                    triples_to_be_removed.append((s, p, o))
                if p in unstarted_rel:
                    triples_to_be_removed.append((s, p, o))
            for t in triples_to_be_removed:
                seg.rdf_graph.remove(t)
            filename, ext = os.path.splitext(args.rdf_turtle_file)
            res_filename = '{0}_segmented_{1}_{2}{3}'.format(filename, t_start, t_end, ext)
            with open(res_filename, 'w') as f:
                f.write(seg.rdf_graph.serialize(format='n3'))
            if VERBOSE:
                print '*' * 30
                print 'Created graph for the interval [{0}, {1}] ({2})'.format(t_start, t_end, res_filename)
                self.print_graph_summary()
            for t in triples_to_be_removed:
                seg.rdf_graph.add(t)

    def mark_graph(self, t_start, t_end):
        unfinished = set()
        unstarted_resources = set()
        unstarted_relations = set()
        for s, o, i, d in self.graph.edges_iter(keys=True, data=True):
            pred_str = str(d['label'])
            # A subject that starts after t_end is marked as unstarted
            if (pred_str == STARTED_AT_TIME or pred_str == TIME) and int(o) > t_end:
                unstarted_resources.add(s)
            # A subject that ends after t_end is marked as unfinished
            elif pred_str == ENDED_AT_TIME and int(o) > t_start:
                unfinished.add(s)
        unstarted_res_stack = list(unstarted_resources)
        while unstarted_res_stack != []:
            n = unstarted_res_stack.pop()
            for s in self.graph.predecessors(n):
                for i in range(len(self.graph[s][n])):
                    if s in unstarted_resources:
                        continue
                    pred_str = str(self.graph[s][n][i]['label'])
                    # 1) An entity "generated by" an unstarted resource is marked as unstarted
                    # 2) An entity "derived from" and unstarted resource is marked as unstarted
                    if pred_str == WAS_GENERATED_BY or pred_str == WAS_DERIVED_FROM:
                        unstarted_resources.add(s)
                        unstarted_res_stack.append(s)
                        sys.exit()
                    # a) A "used" edge pointing into an unstarted entity is marked as unstarted
                    # b) A "was accessed by" edge pointing into an unstarted entity is marked as unstarted
                    if pred_str == USED or pred_str == WAS_ACCESSED_BY:
                        unstarted_relations.add((s, n, self.graph[s][n][i]['label']))
                        print s

        # TODO: Deal similarly as above with unfinished resources

        return unstarted_resources, unstarted_relations

    def print_graph_summary(self, recalculate=True):
        print '#triples = {0}'.format(len(self.rdf_graph))
        predicates = set([str(p) for (s, p, o) in self.rdf_graph])
        print '#predicates = {0}'.format(len(predicates))
        print 'predicates:'
        for p in predicates:
            print '\t', p
        # for stmt in self.rdf_graph:
        #    print stmt
        # for u, v in self.graph.edges():
        #    print u, v, self.graph[u][v]['label']
        if recalculate:
            self.smallest_time = None
            self.biggest_time = None
            for s, p, o in self.rdf_graph:
                if str(p) == STARTED_AT_TIME or str(p) == TIME:
                    self.smallest_time = int(o) if not self.smallest_time or self.smallest_time > int(o) \
                        else self.smallest_time
                if str(p) == ENDED_AT_TIME or str(p) == TIME:
                    self.biggest_time = int(o) if not self.biggest_time or self.biggest_time < int(o) \
                        else self.biggest_time
        try:
            print 'Smallest absolute time (A): {0}'.format(self.smallest_time)
            print 'Biggest absolute time (B): {0}'.format(self.biggest_time)
            print 'Length of time interval (B-A): {0}'.format(self.biggest_time - self.smallest_time)
        except:
            pass

if __name__ == "__main__":
    # Read file
    parser = argparse.ArgumentParser(description='A simple RDF segmenter')
    parser.add_argument('rdf_turtle_file', help='An RDF in turtle format')
    parser.add_argument('interval_duration', type=int,
                        help='The interval duration for the time-based segmentation (in microseconds)')
    parser.add_argument('--verbose', '-v', action='store_true', help='Run in verbose mode')
    parser.add_argument('--summary', '-s', action='store_true', help='Print a summary of the ' +
                                                                     'input graph an quit, interval_duration is ignored')

    args = parser.parse_args()
    VERBOSE = args.verbose
    # Check that provided non-optional files actually exist
    for f in [args.rdf_turtle_file]:
        if not (os.path.isfile(f)):
            print 'File {0} does not exist...aborting'.format(f)

    g = rdflib.Graph()
    seg = Segmenter(args.rdf_turtle_file, args.interval_duration)
    if VERBOSE or args.summary:
        seg.print_graph_summary()
        if args.summary:
            sys.exit()

    seg.segment()

    sys.exit()

    seg.segment((seg.biggest_time - seg.smallest_time) / 10)


    ####
    ### This is code for segmenting a fixed interval
    ###
    unstarted_res, unstarted_rel = seg.mark_graph(62279, 9999999999)
    triples_to_be_removed = []
    for (s, p, o) in seg.rdf_graph:
        if s in unstarted_res or o in unstarted_res:
            triples_to_be_removed.append((s, p, o))
        if p in unstarted_rel:
            triples_to_be_removed.append((s, p, o))
    print len(triples_to_be_removed)
    for t in triples_to_be_removed:
        seg.rdf_graph.remove(t)

    print len(seg.rdf_graph)
    filename, ext = os.path.splitext(args.rdf_turtle_file)
    res_filename = '{0}_segmented{1}'.format(filename, ext)
    with open(res_filename, 'w') as f:
        f.write(seg.rdf_graph.serialize(format='n3'))
